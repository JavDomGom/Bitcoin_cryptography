\documentclass{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{minted}
\usepackage{courier}
\usepackage[dvipsnames]{xcolor}
\usepackage{relsize}

\definecolor{red}{rgb}{0.95,0.12,0.14}
\definecolor{green}{rgb}{0.47,0.58,0.17}
\definecolor{darkTurquoise}{rgb}{0.18,0.65,0.74}
\definecolor{blue}{rgb}{0.16,0,0.98}
\definecolor{purple}{rgb}{0.65,0.03,0.69}

\title{\textbf{Criptografía aplicada: Cálculo del hash SHA-256 de un bloque Bitcoin}}
\author{Javier Domínguez Gómez \\
\small{jdg@member.fsf.org} \\
\small{Fingerprint: 94AD 19F4 9005 EEB2 3384 C20F 5BDC C668 D664 8E2B}}
\date{v0.1.03 - Febrero 2019}

\begin{document}
\maketitle

\tableofcontents{}

\section{Introducción}
    Este documento describe en detalle cada una de las partes de las que se compone un bloque en la cadena de bloques de Bitcoin. También describe el tipo y la distribución de los datos en el bloque, así como las operaciones lógico-matemáticas de la función criptográfica SHA-256 que se emplean con el fin de generar el \textit{hash} adecuado que finalmente representará dicho bloque en la cadena de bloques.

\section{Estructura de datos de un bloque}
    \vspace{3mm}
    Cada bloque de la cadena de bloques de Bitcoin se compone de una serie de datos ordenados meticulosamente y con una lógica definida que se explicará en los siguientes puntos. Cada uno de estos datos tiene sus propios atributos, como puede ser el tipo de dato, el nombre, el tamaño que ocupa en memoria y el formato en el que este se representará. En la siguiente tabla se categorizan los más significativos.
    \begin{table}[H]
    \centering
    \begin{tabular}{| c | l | c | l |} 
        \hline
        Tipo de dato & Nombre & Tamaño & Formato \\
        \hline
        uint32\_t & magicID & 4 bytes & Little-endian \\
        \hline
        uint32\_t & headerLenght & 4 bytes & Big-endian \\
        \hline
        uint32\_t & versionNumber & 4 bytes & Little-endian \\
        \hline
        uint8\_t[32] & previousBlockHash & 32 bytes & Big-endian \\
        \hline
        uint8\_t[32] & merkleRoot & 32 bytes & Big-endian \\
        \hline
        uint32\_t & timeStamp & 4 bytes & Little-endian \\
        \hline
        uint32\_t & targetDifficulty & 4 bytes & Little-endian \\
        \hline
        uint32\_t & nonce & 4 bytes & Little-endian \\
        \hline
        uint8/16/32/64\_t & transactionCount & 1, 3, 5 o 9 bytes & Big-endian*  \\
        \hline
    \end{tabular}
    \caption{Principales datos de un bloque en la cadena de bloques de Bitcoin.}
    \label{table:0}
    \end{table}
    
    \begin{enumerate}
        \item \textbf{magicID}: En la red de Bitcoin se establecen conexiones entre los nodos con la finalidad de establecer una comunicación para el envío y recepción de datos o mensajes. Los mensajes se envían mediante un canal en el que según van llegando se van concatenando uno detrás de otro. Así pues, cuando se desarrolló el protocolo Bitcoin se vio conveniente añadir un prefijo en cada mensaje anteponiendo este dato de 4 bytes y así poder identificar fácilmente no solo la red de Bitcoin en la que se generan, si no también dónde empieza y termina cada mensaje que circula entre los diferentes nodos de la red. La siguiente tabla muestra los diferentes valores que puede tener la variable \textit{magicID} dependiendo de la red.
        
        \begin{table}[H]
        \centering
        \begin{tabular}{| c | c |} 
            \hline
            Red & magicID \\
            \hline
            Mainnet & \texttt{0xf9beb4d9} \\
            \hline
            Testnet & \texttt{0xfabfb5da} \\
            \hline
            Testnet3 & \texttt{0x0b110907} \\
            \hline
            Namecoin & \texttt{0xf9beb4fe} \\
            \hline
            Regtest & \texttt{0xfabfb5da} \\
            \hline
        \end{tabular}
        \label{table:1}
        \end{table}
        
        Se decidió establecer estos valores tan específicos dada la improbabilidad de que los caracteres ASCII que representan se encuentren en un mensaje estándar, tal y como se indica en el archivo \textit{chainparams.cpp}\footnote{https://github.com/bitcoin/bitcoin/blob/master/src/chainparams.cpp\#L99} que lo implementa en el código de Bitcoin.
    
        \item \textbf{headerLenght}: En un dato numérico hexadecimal de 4 bytes y de valor variable que representa la longitud en bytes del bloque actual. Está codificado en formato \textit{Big-endian}
        
        \item \textbf{versionNumber}: Este dato hexadecimal puede cambiar de valor cuando se actualiza el software y cambia el número de la versión del protocolo. Se codifica en formato \textit{Little-endian}.
        
        \item \textbf{previousBlockHash}: Se trata del \textit{hash} o \textit{digest} resultante del bloque anterior tras aplicar las funciones criptográficas utilizando los datos de la cabecera de dicho bloque. Tiene una longitud de 256 bits o 32 bytes codificado en formato \textit{Big-endian}.
        
        \item \textbf{merkleRoot}: Cada vez que una nueva transacción es aceptada el valor de esta variable se modifica. Se trata de un \textit{hash} hexadecimal de 32 bytes codificado en formato \textit{Big-endian}. Para obtener el \textit{hash} final, también llamado \textit{hash root} se han de concatenar los datos de las transacciones ubicados en los nodos hoja del árbol, en grupos de dos. De ese modo, por cada dos transacciones se obtiene un \textit{hash} nuevo que será incluido en un nuevo vector que repetirá la acción hasta llegar al \textit{hash root}.
        
        \begin{figure}[H]
        \centering
            \includegraphics[scale=0.53]{img/Merkle_tree_05_leaves_nodes}
            \caption{Ejemplo de árbol de Merkle con 5 nodos hoja}
        \end{figure}
        
        Cada uno de los vectores $\mathbf{v} \ = \langle v_{1}, v_{2}, \dots, v_{n - 1}, v_{n} \rangle$ irá reduciendo el numero de nodos o elementos mediante la siguiente función recursiva por intervalos o algoritmo de complejidad $O(n)$.
        
        \begin{figure}[H]
        \centering
            $f(\mathbf{v}) = \mathlarger{\sum}_{i=0}^{n} \left \{
            \begin{array}{ll}
                \langle \mathbf{v}^{\prime}, v_{i}\rangle & \mbox{si } i=n-1 \\
                \langle \mathbf{v}^{\prime}, v_{i}||v_{i+1} \rangle & \mbox{si } i < n \\
                i+2
            \end{array}
            \right .$
        \end{figure}
        A continuación un ejemplo escrito en lenguaje C++ que implementa dicho algoritmo:
        
        \begin{minted}[fontsize=\small]{cpp}
#include <iostream>
#include <sstream>
#include <vector>
#include "sha256.h"
 
using namespace std;
 
void printVector(vector<string>);
string merkleTree(vector<string>);
string merkleTreeRoot;
 
int main(int argc, char *argv[]) {
    string msg = argv[1];
    istringstream buf(msg);
    vector<string> leafNodesV;
    
    for (string node; buf >> node;)
        leafNodesV.push_back(sha256(node));
        
    printVector(leafNodesV);
    cout << "Root: " << merkleTree(leafNodesV) << endl;
    
    return 0;
}

string merkleTree(vector<string> v) {
    if (v.size() > 1) {
        vector<string> aux;
        int i;
        
        for (i = 0; i < v.size(); i += 2) {
            if (i == v.size() - 1) {
                aux.push_back(v[i]);
            } else if (i < v.size()) {
                aux.push_back(sha256(v[i] + v[i + 1]));
            }
        }
        merkleTree(aux);
    } else if(v.size() == 1){
        merkleTreeRoot = v[0];
    }
    
    return merkleTreeRoot;
}

void printVector(vector<string> v) {
    cout << "v.size() = " << v.size() << endl;
    int i = 0;
    while (i < v.size()) {
        cout << "v[" << i << "]: " << v[i] << endl;
        i++;
    }
}
        \end{minted}
        
        \item \textbf{timeStamp}: Se trata de un número entero sin signo de 4 bytes también llamado \textit{Epoch} o \textit{Tiempo Unix}. Representa el número de segundos que han transcurrido desde el 1 de enero de 1970 a las 00:00. Se codifica en formato \textit{Little-endian}.
        
        Un ejemplo de cómo se puede calcular este dato es mediante el siguiente código C. Nótese que las horas se procesan como \textit{GMT+1}.
        
        \begin{minted}[fontsize=\small]{c}
#include <stdio.h>
#include <time.h>

int main(int argc, char *argv[]) {
    int year, month, day, hour, minute, second;
    struct tm t;
    time_t tod;
    
    printf("Year: ");
    scanf("%d", &year);
    printf("Month: ");
    scanf("%d", &month);
    printf("Day: ");
    scanf("%d", &day);
    printf("Hour: ");
    scanf("%d", &hour);
    printf("Minute: ");
    scanf("%d", &minute);
    printf("Second: ");
    scanf("%d", &second);
    
    t.tm_year = year - 1900;
    t.tm_mon = month - 1;   // Values [0-11]
    t.tm_mday = day;
    t.tm_hour = hour + 1;   // GMT+1
    t.tm_min = minute;
    t.tm_sec = second;
    t.tm_isdst = 0;         // DST = 0
    tod = mktime(&t);
    
    printf("Timestamp epoch: %ld\n", (long) tod);
}
        \end{minted}
        
    
        \item \textbf{targetDifficulty}: Se trata de un número entero de 256 bits representado como un número decimal muy grande, tanto que abarcaría el rango de números existentes entre $0$ y $2^{256}-1$. Su función es la de definir una variable más a tener en cuenta a la hora de obtener el hash adecuado de un bloque antes de ser minado. Así pues la prueba de trabajo o \textit{Proof of Work} tendrá mayor o menor dificultad. En el protocolo de Bitcoin se define una regla que dice que el \textit{hash} del bloque ha de ser un número menor o igual al valor de la variable \textit{targetDifficulty} en ese momento. Así pues, si el \textit{hash} obtenido como candidato a generar un bloque fuera un número menor o igual al de \textit{targetDifficulty} habría posibilidades para que el \textit{hash} candidato sea un \textit{hash} válido para generar un nuevo bloque, aunque de forma adicional se han de cumplir otras condiciones. Por el contrario, si el \textit{hash} obtenido como candidato fuera un número mayor que el valor de la variable \textit{targetDifficulty}, se ha de incrementar el valor de la variable \textit{nonce} y probar otra vez a generar un \textit{hash} nuevo.
        
        \begin{figure}[H]
        \centering
            \includegraphics[scale=0.39]{img/Bitcoin_TargetDifficulty.png}
            \caption{Valor de la variable \textit{targetDifficulty} desde enero de 2009 hasta hoy.}
        \end{figure}
        
        El valor de la variable \textit{targetDifficulty} se modifica automáticamente una vez se han generado 2016 bloques, esto sucede aproximadamente cada dos semanas. El nuevo valor se obtiene mediante un cálculo que realizan todos los clientes Bitcoin de la red en el que toman el tiempo real que ha llevado generar los 2016 bloques y se obtiene la diferencia porcentual respecto al número de bloques que se esperaba haber calculado en el periodo de dos semanas.
        
        \item \textbf{nonce}: Se trata de un número entero sin signo aleatorio con una longitud de 32 bits o 4 bytes codificado en formato \textit{Little-endian}. Es el dato que ha de cambiarse tras un intento fallido por encontrar el hash del bloque adecuado, de modo que se incrementa y se han de realizar de nuevo todos los cálculos criptográficos teniendo en cuenta el nuevo valor de esta variable.
        
        \item \textbf{transactionCount}: En el caso de \textit{transactionCount} el tipo de dato es un entero sin signo de longitud variable. Como el propio nombre indica, dependiendo del número de transacciones que han sido procesadas tendrá un valor numérico u otro.
        
        *Cuando se le asigna por valor un entero muy grande se codifica en formato \textit{Little-endian}.
    \end{enumerate}
    
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.47]{img/Bitcoin_block_SHA_256_Block_Data}
        \caption{Datos empleados para la obtención del \textit{hash} del bloque \#$286819$.}
    \end{figure}
    
    \vspace{3mm}

\section{Almacenamiento en ficheros}
    Así es como se ven los datos de un bloque almacenados en un fichero blk*.dat.
    \begin{figure}[H]
    \scriptsize{\texttt{$\sim\$$ hexdump\ -C\ -s\ 93725126\ -n\ 288\ blk00116.dat}}
    
    \scriptsize{
    \texttt{059621c6  \textbf{\textcolor{red}{f9 be b4 d9} \textcolor{green}{bd 53 02 00}  \textcolor{darkTurquoise}{02 00 00 00 17 97 5b 97}}  |.....S........[.|} \\
    \texttt{059621d6  \textbf{\textcolor{darkTurquoise}{c1 8e d1 f7 e2 55 ad f2  97 59 9b 55 33 0e da b8}}  |.....U...Y.U3...|} \\
    \texttt{059621e6  \textbf{\textcolor{darkTurquoise}{78 03 c8 17 01 00 00 00  00 00 00 00 8a 97 29 5a}}  |x.............)Z|} \\
    \texttt{059621f6  \textbf{\textcolor{darkTurquoise}{27 47 b4 f1 a0 b3 94 8d  f3 99 03 44 c0 e1 9f a6}}  |'G.........D....|} \\
    \texttt{05962206  \textbf{\textcolor{darkTurquoise}{b2 b9 2b 3a 19 c8 e6 ba  dc 14 17 87 35 8b 05 53}}  |..+:........5..S|} \\
    \texttt{05962216  \textbf{\textcolor{darkTurquoise}{53 5f 01 19 48 75 08 33}  \textcolor{blue}{63} \textcolor{purple}{01 00 00 00 01 00 00}}  |S\_..Hu.3c.......|} \\
    \texttt{05962226  \textbf{\textcolor{purple}{00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00}}  |................|} \\
    \texttt{05962236  \textbf{\textcolor{purple}{00 00 00 00 00 00 00 00  00 00 00 00 00 00 ff ff}}  |................|} \\
    \texttt{05962246  \textbf{\textcolor{purple}{ff ff 60 03 63 60 04 06  2f 50 32 53 48 2f 04 35}}  |..`.c`../P2SH/.5|} \\
    \texttt{05962256  \textbf{\textcolor{purple}{8b 05 53 08 44 04 f2 53  00 00 17 e4 46 52 2c fa}}  |..S.D..S....FR,.|} \\
    \texttt{05962266  \textbf{\textcolor{purple}{be 6d 6d 69 06 88 fb 88  6c 0d f0 c8 7c bc 7e a4}}  |.mmi....l...|.~.|} \\
    \texttt{05962276  \textbf{\textcolor{purple}{f7 f1 b5 c0 05 0b d0 ac  37 51 cf c9 97 d9 d6 97}}  |........7Q......|} \\
    \texttt{05962286  \textbf{\textcolor{purple}{13 28 de 04 00 00 00 00  00 00 00 48 61 70 70 79}}  |.(.........Happy|} \\
    \texttt{05962296  \textbf{\textcolor{purple}{20 4e 59 21 20 59 6f 75  72 73 20 47 48 61 73 68}}  | NY! Yours GHash|} \\
    \texttt{059622a6  \textbf{\textcolor{purple}{2e 49 4f 00 00 00 00 01  cb 81 31 95 00 00 00 00}}  |.IO.......1.....|} \\
    \texttt{059622b6  \textbf{\textcolor{purple}{19 76 a9 14 80 ad 90 d4  03 58 1f a3 bf 46 08 6a}}  |.v.......X...F.j|} \\
    \texttt{059622c6  \textbf{\textcolor{purple}{91 b2 d9 d4 12 5d b6 c1  88 ac 00 00 00 00 01 00}}  |.....]..........|} \\
    \texttt{059622d6  \textbf{\textcolor{purple}{00 00 01 7d 67 7c de 17  3f 8c bf 43 31 27 a8 5e}}  |...\}g|..?..C1'.\textasciicircum|}
    }
    \end{figure}
    
\section{Construcción de la cadena de entrada M}
    En este ejemplo se tratarán los datos reales del bloque $\#286819$ de la cadena de bloques de Bitcoin. Este bloque tiene el siguiente \textit{hash}.
    
    \begin{figure}[H]
        \centering
        \scriptsize{
        \texttt{0000000000000000e067a478024addfecdc93628978aa52d91fabd4292982a50}
        }
    \end{figure}
    
    Los datos correspondientes a la cabecera o \textit{header} son los siguientes:
    \begin{figure}[H]
    \centering
    \scriptsize{
        $\begin{array}{ll}
            \texttt{Version:} & \texttt{2} \\
            \texttt{Prev. Block:} & \texttt{000000000000000117c80378b8da0e33559b5997f2ad55e2f7d18ec1975b9717} \\
            \texttt{Merkle root:} & \texttt{871714dcbae6c8193a2bb9b2a69fe1c0440399f38d94b3a0f1b447275a29978a} \\
            \texttt{Timestamp:} & \texttt{2014-02-20 04:57:25 (Epoch timestamp: 1392872245)} \\
            \texttt{Bits:} & \texttt{419520339} \\
            \texttt{Nonce:} & \texttt{856192328} \\
        \end{array}$
    }
    \end{figure}
    
    Pasamos los datos decimales a formato hexadecimal:
    \begin{figure}[H]
    \centering
    \scriptsize{
        $\begin{array}{ll}
            \texttt{Version:} & \texttt{00000002} \\
            \texttt{Prev. Block:} & \texttt{000000000000000117c80378b8da0e33559b5997f2ad55e2f7d18ec1975b9717} \\
            \texttt{Merkle root:} & \texttt{871714dcbae6c8193a2bb9b2a69fe1c0440399f38d94b3a0f1b447275a29978a} \\
            \texttt{Timestamp:} & \texttt{53058B35} \\
            \texttt{Bits:} & \texttt{19015F53} \\
            \texttt{Nonce:} & \texttt{33087548} \\
        \end{array}$
    }
    \end{figure}
    
    Se reorganizan los datos en formato Little Endian:
    \begin{figure}[H]
    \centering
    \scriptsize{
        $\begin{array}{ll}
            \texttt{Version:} & \texttt{02000000} \\
            \texttt{Prev. Block:} & \texttt{17975b97c18ed1f7e255adf297599b55330edab87803c8170100000000000000} \\
            \texttt{Merkle root:} & \texttt{8a97295a2747b4f1a0b3948df3990344c0e19fa6b2b92b3a19c8e6badc141787} \\
            \texttt{Timestamp:} & \texttt{358B0553} \\
            \texttt{Bits:} & \texttt{535F0119} \\
            \texttt{Nonce:} & \texttt{48750833} \\
        \end{array}$
    }
    \end{figure}
    
    Finalmente se concatenan uno a continuación de otro, empezando por versión, hash del bloque anterior, merkle root, timestamp, bits y nonce, formando una cadena de entrada $M$ de 160 carácteres hexadecimales con con un tamaño total de 640 bits.
    
    \begin{figure}[H]
    \centering
        $\begin{array}{rcl}
             M & = & \left \{
            \begin{array}{c}
                \texttt{0200000017975b97c18ed1f7e255adf2} \\
                \texttt{97599b55330edab87803c81701000000} \\
                \texttt{000000008a97295a2747b4f1a0b3948d} \\
                \texttt{f3990344c0e19fa6b2b92b3a19c8e6ba} \\
                \texttt{dc141787358b0553535f011948750833}
            \end{array}
            \right .
        \end{array}$
    \end{figure}
    
    Se segmenta la cadena de entrada $M$ en bloques de 32 bits:
    \begin{figure}[H]
    \centering
        $\begin{array}{rcl}
             M & = & \left \{
            \begin{array}{c}
                \texttt{02000000 + 17975b97 + c18ed1f7 + e255adf2} \\
                \texttt{97599b55 + 330edab8 + 7803c817 + 01000000} \\
                \texttt{00000000 + 8a97295a + 2747b4f1 + a0b3948d} \\
                \texttt{f3990344 + c0e19fa6 + b2b92b3a + 19c8e6ba} \\
                \texttt{dc141787 + 358b0553 + 535f0119 + 48750833}
            \end{array}
            \right .
        \end{array}$
    \end{figure}

\section{Longitud de la cadena $M$ de entrada}
    Una vez que se ha obtenido la cadena de entrada $M$ en el punto anterior es necesario calcular la longitud de la misma en formato hexadecimal o base 16, es decir, 640 bits que se representan con el valor 280 en hexadecimal.
    \begin{figure}[H]
    \centering
        $|M| = 280\ (640\ bits\ del\ mensaje\ original\ en\ hexadecimal)$
    \end{figure}
    Este dato se ha de reservar para el siguiente punto, ya que será necesario para completar los registros $W_{14}$ y $W_{15}$ de la variable $W_t$ solo en la segunda y tercera ejecución de la función SHA-256.
    
\section{Los 16 registros de $W_t$}
    Tal y como se describe en el punto 3 del documento "\textit{Criptografíıa aplicada: Función SHA-256}"\footnote{https://github.com/JavierDominguezGomez/Cryptography/blob/master/SHA-256/Cryptography\_SHA-256\_es.pdf}, la variable $W_{t}$ es un vector de 64 elementos que contiene palabras hexadecimales de 32 bits. Tiene un tamaño o longitud de 2048 bits (256 bytes) y se obtiene mediante la siguiente función recursiva definida por intervalos.
        \begin{figure}[H]
        \centering
            $W_{t} = \left \{
            \begin{array}{lcl}
                M_{i} & si & 0 \le i < 16 \\
                \sigma_{1}(W_{i-2})+W_{i-7}+\sigma_{0}(W_{i-15})+W_{i-16} & si & 16 \le i < 64
            \end{array}
            \right .$
        \end{figure}
    En la anterior función recursiva definida por intervalos, el primer intervalo es el que abarca los 16 primeros registros, o sea desde $W_{0}$ hasta $W_{15}$. El segundo intervalo es el esquema de los 48 registros restantes, es decir, desde $W_{16}$ hasta $W_{65}$.
        \begin{figure}[H]
        \centering
            \includegraphics[scale=0.5]{img/SHA-256-Wt.png}
            \caption{Representación gráfica de $W_{t}$}
        \end{figure}
    Las funciones  $\sigma_{0}$ y $\sigma_{1}$ realizan las siguientes operaciones lógicas de compresión con cada uno de los bits de la palabra almacenada en el segmento de $W_t$ que procesan.
        \begin{figure}[H]
        \centering
            $\begin{array}{l}
                \sigma_{0}(x) = ROT \ R^{7}(x) \oplus ROT \ R^{18}(x) \oplus SHR^{3}(x) \\
                \sigma_{1}(x) = ROT \ R^{17}(x) \oplus ROT \ R^{19}(x) \oplus SHR^{10}(x)
            \end{array}$
        \end{figure}
    
    Para hallar el valor de cualquiera de los segmentos que van desde $W_{16}$ hasta $W_{63}$ se han de realizar las siguientes operaciones, donde $i$ tiene por valor el valor de $t$ en el segmento que se quiere calcular de $W_t$. Por ejemplo, para $W_{16}$:
    
    \begin{figure}[H]
    \centering
        $\sigma_{1}(W_{i-2})+W_{i-7}+\sigma_{0}(W_{i-15})+W_{i-16}$ \\
        $\Downarrow$ \\
        $\sigma_{1}(W_{16-2})+W_{16-7}+\sigma_{0}(W_{16-15})+W_{16-16}$ \\
        $\Downarrow$ \\
        $\sigma_{1}(W_{14})+W_{9}+\sigma_{0}(W_{1})+W_{0}$
    \end{figure}
    
    En este ejemplo los segmentos $W_{14}$, $W_{9}$, $W_{1}$ y $W_{0}$ de la primera ronda (\textit{Ronda \texttt{\#}0}) tienen asignados los siguientes valores:
    \begin{figure}[H]
    \centering
        $\begin{array}{rl}
            W_{14} = \texttt{0xb2b92b3a} & W_{9} = \texttt{0x8a97295a} \\
            W_{1}\  = \texttt{0x17975b97} & W_{0} = \texttt{0x02000000}
        \end{array}$
    \end{figure}
    
    A continuación se muestra una representación gráfica la operación lógica de compresión $\sigma_{1}$, que aplica sobre el valor del segmento $W_{14}$.
    
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.445]{img/SHA-256-Wt_operacion_sigma1.png}
        \caption{Operación $ROT \ R^{17}(x) \oplus ROT \ R^{19}(x) \oplus SHR^{10}(x)$ con cada bit.}
    \end{figure}
    
    Tras el cálculo de $\sigma_{1}(W_{14})$ se obtiene la palabra hexadecimal de 32 bits $\texttt{b0d6a141}$. Se ha de reservar este valor para calcular el resultado final. También se muestra la la representación gráfica la operación lógica de compresión $\sigma_{0}$, que aplica sobre el valor del segmento $W_{1}$.
    
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.445]{img/SHA-256-Wt_operacion_sigma0.png}
        \caption{Operación $ROT \ R^{7}(x) \oplus ROT \ R^{18}(x) \oplus SHR^{3}(x)$ con cada bit.}
    \end{figure}
    
    Tras el cálculo de $\sigma_{0}(W_{1})$ se obtiene la palabra hexadecimal de 32 bits $\texttt{fa380020}$. Una vez realizados los cálculos necesarios para obtener el valor de $\sigma_{1}(W_{14})$ y $\sigma_{0}(W_{1})$ finalmente se ha de realizar la siguiente operación final.
    
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.445]{img/SHA-256-Wt_operacion_mod2_32_final.png}
        \caption{Operación final $mod \ 2^{32} (\sigma_{1}(W_{14}), W_9, \sigma_{0}(W_{1}), W_0)$.}
    \end{figure}
    
    Estas normas también aplican a las reglas criptográficas de los bloques en el protocolo Bitcoin, solo que hay que tener en cuenta que la cadena de entrada $M$ en cada bloque tiene una longitud superior a 512 bits, lo que implica utilizar la función \textit{hash} SHA-256 tres veces, una por cada ronda, y el valor de la longitud de $M$ solo se aplicará en el esquema de relleno de la segunda y tercera ronda. En la primera ronda (\textit{Ronda \texttt{\#}0}) se rellenan los primeros 16 segmentos de la variable $W_t$ con todos los bytes en hexadecimal que quepan, es decir, los primeros 512 bits de $M$, rellenando también los segmentos $W_{14}$ y $W_{15}$. Los 128 bits restantes de la cadena de entrada $M$ que no caben en esta primera ronda se reservan para los primeros 4 registros de $W_t$ de la segunda ronda. Tras la segunda ronda (\textit{Ronda \texttt{\#}1}) se obtiene un \textit{digest} de 256 bits que se utiliza para rellenar los primeros 8 segmentos de $W_t$ en la tercera y última ronda (\textit{Ronda \texttt{\#}2}). La siguiente figura se detalla el contenido de los primeros 16 registros de la variable $W_{t}$ en cada una de las tres veces que se ejecutan las 64 iteraciones de la función SHA-256 para obtener el \textit{digest} en cada caso.
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.59]{img/Bitcoin_block_SHA_256_W0_W15_x3}
        \caption{Los primeros 16 registros de la variable $W_{t}$ en los tres casos en los que se ha de ejecutar la función SHA-256.}
    \end{figure}
    
    En los siguientes puntos se detalla el esquema de relleno al completo en cada una de las rondas.
    
    \subsection{Primera ronda SHA-256: Ronda 0}
    La función \textit{hash} SHA-256 realiza 64 ciclos criptográficos en los que procesará una serie de cálculos en los que tiene en cuenta por un lado las 8 palabras hexadecimales de 32 bits asignadas como valor a las variables $A$, $B$, $C$, $D$, $E$, $F$, $G$ y $H$, y por otro lado la variable $W_t$, que es un vector de 64 elementos ordenados por intervalos.
    
    \noindent\begin{minipage}{0.3\textwidth}
    \includegraphics[scale=0.59]{img/Bitcoin_block_SHA_256_W0_W15_ronda_0}
    \end{minipage}
    \hfill
    \begin{minipage}{0.6\textwidth}
    En la primera ronda criptográfica se han iniciar los valores de las variables $A_{0}$, $B_{0}$, $C_{0}$, $D_{0}$, $E_{0}$, $F_{0}$, $G_{0}$ y $H_{0}$ con los valores estándar de la función \textit{hash} SHA-256 en su primera iteración, es decir, los 32 primeros bits en hexadecimal o base 16 de la parte fraccionaria de las raíces cuadradas de los primeros 8 números primos.
    
    \begin{figure}[H]
    \centering
        $\begin{array}{rr}
            A_{0} = \texttt{0x6a09e667} & B_{0} = \texttt{0xbb67ae85} \\
            C_{0} = \texttt{0x3c6ef372} & D_{0} = \texttt{0xa54ff53a} \\
            E_{0} = \texttt{0x510e527f} & F_{0} = \texttt{0x9b05688c} \\
            G_{0} = \texttt{0x1f83d9ab} & H_{0} = \texttt{0x5be0cd19}
        \end{array}$
    \end{figure}
    
    En una función SHA-256, cuando el tamaño de la cadena de entrada $M$ es igual o mayor que 512 bits se han de rellenar los primeros 16 elementos del vector $W_t$ con los primeros 512 bits de la cadena principal de entrada $M$, incluidos los elementos $W_{14}$ y $W_{15}$, tal y como se muestra en la imagen. El resto de la cadena $M$ se ha de reservar para la segunda ejecución de la función SHA-256 que se explicará en el siguiente punto.
    \end{minipage}
    
    \vspace{1mm}
    
    Teniendo la cadena $M$ de entrada, las 8 palabras iniciales, que irán cambiando en cada una de las 64 iteraciones, y los 64 elementos del vector $W_t$ se puede comenzar a realizar las operaciones de la función SHA-256. El objetivo en esta primera ronda es obtener el primer \textit{hash}, necesario en la segunda ronda.
    
    \vspace{3mm}
    
    Cuando se hayan realizado las 64 iteraciones SHA-256 con los datos anteriores se ha de realizar una última operación en la que se ha de tomar cada palabra $A$, $B$, $C$, $D$, $E$, $F$, $G$ y $H$ de la primera iteración y realizar  una operación $mod\ 2^{32}$ con su homóloga de la última iteración, véase el ejemplo.
    
    \begin{figure}[H]
    \centering
        $\begin{array}{lll}
            A_0 & mod\ 2^{32} & A_{63} \\
            B_0 & mod\ 2^{32} & B_{63} \\
            C_0 & mod\ 2^{32} & C_{63} \\
            D_0 & mod\ 2^{32} & D_{63} \\
            E_0 & mod\ 2^{32} & E_{63} \\
            F_0 & mod\ 2^{32} & F_{63} \\
            G_0 & mod\ 2^{32} & G_{63} \\
            H_0 & mod\ 2^{32} & H_{63}
        \end{array}$
    \end{figure}
    
    \begin{figure}[H]
    \centering
        $\begin{array}{lllll}
            \texttt{0x6a09e667} & mod\ 2^{32} & \texttt{0x72605526} & = & \texttt{0xdc6a3b8d} \\
            \texttt{0xbb67ae85} & mod\ 2^{32} & \texttt{0x51019395} & = & \texttt{0x0c69421a} \\
            \texttt{0x3c6ef372} & mod\ 2^{32} & \texttt{0x8eab60c2} & = & \texttt{0xcb1a5434} \\
            \texttt{0xa54ff53a} & mod\ 2^{32} & \texttt{0x3fe7029b} & = & \texttt{0xe536f7d5} \\
            \texttt{0x510e527f} & mod\ 2^{32} & \texttt{0x72b36765} & = & \texttt{0xc3c1b9e4} \\
            \texttt{0x9b05688c} & mod\ 2^{32} & \texttt{0xb1b63303} & = & \texttt{0x4cbb9b8f} \\
            \texttt{0x1f83d9ab} & mod\ 2^{32} & \texttt{0x766c3d83} & = & \texttt{0x95f0172e} \\
            \texttt{0x5be0cd19} & mod\ 2^{32} & \texttt{0xa06805c6} & = & \texttt{0xfc48d2df}
        \end{array}$
    \end{figure}
    
    Finalmente se concatenan los valores de los 8 resultados en esta ronda 0 obteniendo el siguiente digest resultante:
    
    \begin{figure}[H]
    \centering
        $\scriptsize{\texttt{dc6a3b8d0c69421acb1a5434e536f7d5c3c1b9e44cbb9b8f95f0172efc48d2df}}$
    \end{figure}
    Se reserva este dato para realizar la segunda ronda SHA-256 en el siguiente punto.
    
    \subsection{Segunda ronda SHA-256: Ronda 1}
    En la segunda ronda se han volver a realizar los 64 ciclos criptográficos que realiza SHA-256 teniendo en cuenta que el valor de las 8 palabras iniciales $A$, $B$, $C$, $D$, $E$, $F$, $G$ y $H$ en la primera iteración tendrán por valor inicial cada uno de los segmentos de 32 bits correspondientes al \textit{hash} resultante de la primera ronda.
    
    \begin{figure}[H]
    \centering
        $\scriptsize{\overbrace{\texttt{dc6a3b8d}}^{A_{0}}\overbrace{\texttt{0c69421a}}^{B_{0}}\overbrace{\texttt{cb1a5434}}^{C_{0}}\overbrace{\texttt{e536f7d5}}^{D_{0}}\overbrace{\texttt{c3c1b9e4}}^{E_{0}}\overbrace{\texttt{4cbb9b8f}}^{F_{0}}\overbrace{\texttt{95f0172e}}^{G_{0}}\overbrace{\texttt{fc48d2df}}^{H_{0}}}$
    \end{figure}
    
    \begin{figure}[H]
    \centering
        $\begin{array}{rr}
            A_{0} = \texttt{0xdc6a3b8d} & B_{0} = \texttt{0xc3c1b9e4} \\
            C_{0} = \texttt{0x0c69421a} & D_{0} = \texttt{0x4cbb9b8f} \\
            E_{0} = \texttt{0xcb1a5434} & F_{0} = \texttt{0x95f0172e} \\
            G_{0} = \texttt{0xe536f7d5} & H_{0} = \texttt{0xfc48d2df}
        \end{array}$
    \end{figure}
    
    En cuanto a los primeros 16 registros de la variable $W_t$ en esta segunda ronda se se utilizarán primero los bits del mensaje $M$ original de 640 bits que no cabían en la ronda anterior.
    \begin{figure}[H]
    \centering
        $\texttt{dc141787+358b0553+535f0119+48750833}$
    \end{figure}
        
    A continuación hay que tomar un bit que represente el número 1 decimal o base 10, es decir $00000001$, este se desplaza al bit más alto del byte, con lo que se obtiene $10000000$ y finalmente se calcula el valor hexadecimal, que es $80$.
        \begin{figure}[H]
        \centering
            $10000000_{2} = \texttt{80}_{16}$
        \end{figure}
    
    Independientemente de la longitud de cadena hexadecimal de la palabra de entrada, se añade $80$ por la derecha.
        \begin{figure}[H]
        \centering
            $\texttt{486f6c61} + \texttt{206d756e} + \texttt{646f} + \texttt{80}$
        \end{figure}
     Ahora hay que añadir a la cadena una cantidad de bits con valor $0$ hasta llegar a 448 bits en total, que es la longitud que abarca todos los intervalos que van desde $W_{0}$ hasta $W_{13}$.
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.59]{img/Bitcoin_block_SHA_256_W0_W15_ronda_1}
    \end{figure}
    Para terminar de completar $W_{t}$ solo queda rellenar los últimos dos bloques de 32 bits $W_{14}$ y $W_{15}$ con la longitud del mensaje de entrada $|M|$ en hexadecimal, con tantos ceros por la izquierda como sean necesario para alcanzar 64 bits de longitud, en este caso es $280$.
    
    \begin{figure}[H]
    \centering
        $\begin{array}{lll}
            \texttt{0xdc6a3b8d}\ (A_0)\ mod\ 2^{32}\ \texttt{0x9fa7eff9}\ (A_63) & = & \texttt{0x7c122b86} \\
            \texttt{0x0c69421a}\ (B_0)\ mod\ 2^{32}\ \texttt{0x1c10fcdd}\ (B_63) & = & \texttt{0x287a3ef7} \\
            \texttt{0xcb1a5434}\ (C_0)\ mod\ 2^{32}\ \texttt{0x1fa7f3ac}\ (C_63) & = & \texttt{0xeac247e0} \\
            \texttt{0xe536f7d5}\ (D_0)\ mod\ 2^{32}\ \texttt{0xc82c78bc}\ (D_63) & = & \texttt{0xad637091} \\
            \texttt{0xc3c1b9e4}\ (E_0)\ mod\ 2^{32}\ \texttt{0x093d1214}\ (E_63) & = & \texttt{0xccfecbf8} \\
            \texttt{0x4cbb9b8f}\ (F_0)\ mod\ 2^{32}\ \texttt{0x12a67774}\ (F_63) & = & \texttt{0x5f621303} \\
            \texttt{0x95f0172e}\ (G_0)\ mod\ 2^{32}\ \texttt{0x77ac085b}\ (G_63) & = & \texttt{0x0d9c1f89} \\
            \texttt{0xfc48d2df}\ (H_0)\ mod\ 2^{32}\ \texttt{0x58cd0707}\ (H_63) & = & \texttt{0x5515d9e6}
        \end{array}$
    \end{figure}
    
    Finalmente se concatenan los valores de los 8 resultados en esta ronda 1 obteniendo el siguiente digest resultante:
    
    \begin{figure}[H]
    \centering
        $\scriptsize{\texttt{7c122b86287a3ef7eac247e0ad637091ccfecbf85f6213030d9c1f895515d9e6}}$
    \end{figure}
    Se reserva este dato para realizar la segunda ronda SHA-256 en el siguiente punto.
    
    \subsection{Tercera ronda SHA-256: Ronda 2}
    \begin{figure}[H]
    \centering
        \includegraphics[scale=0.59]{img/Bitcoin_block_SHA_256_W0_W15_ronda_2}
    \end{figure}
\end{document}
